#!/usr/bin/env python
import rospy
from sensor_msgs.msg import Image
from nav_msgs.msg import Odometry
from package.msg import MeasurementPacket
from active_slam.blob_SAM_node import BlobSAMNode


class SAM_DA_node:

    def __init__(self):

        # Subscribers x2
        self.image_sub = rospy.Subscriber('/airsim_node/Multirotor/front_center_custom/Scene', Image, self.image_callback)
        self.odom_sub = rospy.Subscriber('/airsim_node/Multirotor/odom_local_ned', Odometry, self.odom_callback)

        # Publisher
        self.measurement_pub = rospy.Publisher('/measurement_packet', MeasurementPacket, queue_size=10)

        blob_sam_node = BlobSAMNode()
        blob_sam_node.image = self.last_image
        blob_sam_node.T = self.last_odom
        tracks = blob_sam_node.process_image()

        for track_id, pixel_coords in tracks.items():
            print(f"Track ID: {track_id}, Pixel Coordinates: {pixel_coords}")

        self.last_image = None
        self.last_odom = None

    def image_cb(self, msg):
        # Process image data
        self.last_image = msg
        self.publish_measurement()

    # callback function for the topic /robot_pose
    def robot_pose_cb(self, event):

        # get the robot's pose (TODO: this is getting ground truth pose, but we want to get the estimated pose from the SLAM algorithm)
        print("bofore robot_pose_cb")
        self.drone_client_lock.acquire()
        robot_pose = self.drone_client.simGetGroundTruthKinematics()
        self.drone_client_lock.release()
        print("after robot_pose_cb")

        # update the robot's pose
        self.robot_pose[0] = robot_pose.position.x_val
        self.robot_pose[1] = robot_pose.position.y_val
        self.robot_pose[2] = robot_pose.position.z_val
        self.robot_pose[3] = robot_pose.orientation.x_val
        self.robot_pose[4] = robot_pose.orientation.y_val
        self.robot_pose[5] = robot_pose.orientation.z_val
        self.robot_pose[6] = robot_pose.orientation.w_val

        # print the robot's pose
        print("robot_pose: ", self.robot_pose)

        # update the robot's pose
        self.grid_mapper.update_robot_pose(self.robot_pose.copy())

    def publish_measurement(self):
        if self.last_image is None or self.last_odom is None:
            return  # Do not publish until both messages are received

        # Create a MeasurementPacket
        measurement = MeasurementPacket()
        measurement.seq = self.last_image.header.seq  # Example for sequence number
        measurement.relative_pose = self.last_odom.pose.pose  # Example for relative pose

        # Example for landmarks and pixels (populate these with actual data)
        measurement.landmarks = [1, 2, 3]  # Dummy data
        measurement.pixels = [100, 200, 300]  # Dummy data

        # Publish the measurement packet
        self.measurement_pub.publish(measurement)

if __name__ == '__main__':
    rospy.init_node('SAM_DA_node', anonymous=True)
    SAM_DA_node = SAM_DA_node()
    rospy.spin()
